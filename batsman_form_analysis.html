<!DOCTYPE html>
<html lang="en">

	<head>
		<meta charset="utf-8">
	    <meta http-equiv="X-UA-Compatible" content="IE=edge">
	    <meta name="viewport" content="width=device-width, initial-scale=1">
	    <meta name="description" content="">
	    <meta name="author" content="">

	    <!-- Bootstrap Core CSS -->
	    <link href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" rel="stylesheet">
	    <!-- Custom CSS -->
	    <style>
	    	svg {
			  font: 10px sans-serif;
			}

			.area {
			  fill: none;
			  stroke: steelblue;
			  stroke-width: 3;
			  clip-path: url(#clip);
			}

			.axis path,
			.axis line {
			  fill: none;
			  stroke: #000;
			  shape-rendering: crispEdges;
			}

			.brush .extent {
			  stroke: #fff;
			  fill-opacity: .125;
			  shape-rendering: crispEdges;
			}
		    .bar {
		    	opacity: 0.9;
		        stroke: none;
		        fill: steelblue;
		     }


	    </style>
	    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
	    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
	    <!--[if lt IE 9]>
	        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
	        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
	    <![endif]-->
	</head>
	<body>
		<!-- D3js CDN -->
	    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.16/d3.min.js"></script>
        <div class="container">
        	<!-- All html elements go here. You can have multiple containers, and look -->
        	<!-- up class container-fluid if you want the container to span the entire page -->

        </div>

	    <!-- jQuery Version 1.12.3 -->
        <script   src="https://code.jquery.com/jquery-1.12.3.min.js"   integrity="sha256-aaODHAgvwQW1bFOGXMeX+pC4PZIPsvn2h1sArYOhgXQ="   crossorigin="anonymous"></script>
	    <!-- Bootstrap Core JavaScript -->
	    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>
	    <script>
	    	var margin = {top: 10, right: 10, bottom: 100, left: 40},
			    margin2 = {top: 430, right: 10, bottom: 20, left: 40},
			    width = 960 - margin.left - margin.right,
			    height = 500 - margin.top - margin.bottom,
			    height2 = 500 - margin2.top - margin2.bottom;

			// Sample date time format 1989-12-18T00:00:00.000Z
			var parseDate = d3.time.format("%Y-%m-%dT%H:%M:%S.%LZ").parse;

			var x = d3.time.scale().range([0, width]),
			    x2 = d3.time.scale().range([0, width]),
			    y = d3.scale.linear().range([height, 0]),
			    y2 = d3.scale.linear().range([height2, 0]);

			var xAxis = d3.svg.axis().scale(x).orient("bottom"),
			    xAxis2 = d3.svg.axis().scale(x2).orient("bottom"),
			    yAxis = d3.svg.axis().scale(y).orient("left");

			// The selection which is being passed as an 
			// argument to brush() here is passed through 
			// the .call method we use to call this function later
			var brush = d3.svg.brush()
			    .x(x2)
			    .on("brush", brushed);

			// SVG Generators are functions of data
			// When they are called as attributes for a 
			// selection then whatever data is bound to 
			// that selection is passed onto these generators
			var area = d3.svg.line()
			    .interpolate("linear")
			    .x(function(d) { 
			    	console.log(d['match/startdate']);
			    	console.log(x(parseDate(d['match/startdate'])));
			    	return x(parseDate(d['match/startdate'])); })
			    .y(function(d) { 
			    	console.log(d['batsman/runs']);
			    	console.log(y(d['batsman/runs']));
			    	return y(d['batsman/runs']); 
			    });

			var area2 = d3.svg.line()
			    .interpolate("linear")
			    .x(function(d) { 
			    	return x2(parseDate(d['match/startdate'])); 
			    })
			    .y(function(d) { 
			    	return y2(d['batsman/runs']); 
			    });

			var svg = d3.select("body").append("svg")
			    .attr("width", width + margin.left + margin.right)
			    .attr("height", height + margin.top + margin.bottom);

			svg.append("defs").append("clipPath")
			   .attr("id", "clip")
			   .append("rect")
		       .attr("width", width)
		       .attr("height", height);

		    var focus = svg.append("g")
			    .attr("class", "focus")
			    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");


			var context = svg.append("g")
			    .attr("class", "context")
			    .attr("transform", "translate(" + margin2.left + "," + margin2.top + ")");

			d3.json("tendulkar_35320_odi.json", function(error, data) {

				x.domain(d3.extent(data.map(function(d) { 
					return parseDate(d['match/startdate']); 

				})));
				y.domain([0, d3.max(data.map(function(d) { 
					return d['batsman/runs']; 
				}))]);

				console.log(x.domain());
				x2.domain(x.domain());
				y2.domain(y.domain());

				focus.append("path")
					.datum(data)
					.attr("class", "area")
					// What does this really mean ? Does it call 
					// the area element for all data points ? 

					.attr("d", area);

				focus.append("g")
					.attr("class", "x axis")
					.attr("transform", "translate(0," + height + ")")
					.call(xAxis);

				focus.append("g")
					.attr("class", "y axis")
					// .call is a fancy way of passing the 
					// selection to the function specified
					.call(yAxis);

				context.append("path")
					.datum(data)
					.attr("class", "area")
					.attr("d", area2);

				context.append("g")
					.attr("class", "x axis")
					.attr("transform", "translate(0," + height2 + ")")
					// .call is a fancy way of passing the 
					// selection to the function specified
					.call(xAxis2);

				context.append("g")
					.attr("class", "x brush")
					// .call is a fancy way of passing the 
					// selection to the function specified
					.call(brush)
					.selectAll("rect")
						.attr("y", -6)
						.attr("height", height2 + 7);
			});

			function brushed() {
				x.domain(brush.empty() ? x2.domain() : brush.extent());
				// so focus.select(".area") has data bound to it and hence 
				// when the .attr is passed the area generator 
				// the data bound to the selection is passed to it 
				// Just how generators work 
				// The bound data is also available as a
				// __data__ attribute in the selection 
				// and that is how you could go about doing your own thing with the 
				// data
				focus.select(".area").attr("d", area);

				focus.select(".x.axis").call(xAxis);
				console.log(focus.select(".area"));
			}


	    </script>
	</body>
</html>
